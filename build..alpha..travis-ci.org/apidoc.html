<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/Mashape/unirest-nodejs#readme"

    >unirest (v0.5.1)</a>
</h1>
<h4>Simplified, lightweight HTTP client library</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.unirest">module unirest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.cookie">
            function <span class="apidocSignatureSpan">unirest.</span>cookie
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.delete">
            function <span class="apidocSignatureSpan">unirest.</span>delete
            <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.firstMatch">
            function <span class="apidocSignatureSpan">unirest.</span>firstMatch
            <span class="apidocSignatureSpan">(string, map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.get">
            function <span class="apidocSignatureSpan">unirest.</span>get
            <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.head">
            function <span class="apidocSignatureSpan">unirest.</span>head
            <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.jar">
            function <span class="apidocSignatureSpan">unirest.</span>jar
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.matches">
            function <span class="apidocSignatureSpan">unirest.</span>matches
            <span class="apidocSignatureSpan">(string, map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.options">
            function <span class="apidocSignatureSpan">unirest.</span>options
            <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.patch">
            function <span class="apidocSignatureSpan">unirest.</span>patch
            <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.post">
            function <span class="apidocSignatureSpan">unirest.</span>post
            <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.put">
            function <span class="apidocSignatureSpan">unirest.</span>put
            <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request">
            function <span class="apidocSignatureSpan">unirest.</span>request
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request">
            function <span class="apidocSignatureSpan">unirest.</span>request.Request
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.trim">
            function <span class="apidocSignatureSpan">unirest.</span>trim
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.type">
            function <span class="apidocSignatureSpan">unirest.</span>type
            <span class="apidocSignatureSpan">(type, parse)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unirest.</span>Request</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unirest.</span>Response</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unirest.</span>enum</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unirest.</span>parsers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unirest.</span>request.Request.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unirest.</span>serializers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unirest.Request">module unirest.Request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.Request.serialize">
            function <span class="apidocSignatureSpan">unirest.Request.</span>serialize
            <span class="apidocSignatureSpan">(string, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.Request.uid">
            function <span class="apidocSignatureSpan">unirest.Request.</span>uid
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unirest.Response">module unirest.Response</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.Response.parse">
            function <span class="apidocSignatureSpan">unirest.Response.</span>parse
            <span class="apidocSignatureSpan">(string, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.Response.parseHeader">
            function <span class="apidocSignatureSpan">unirest.Response.</span>parseHeader
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unirest.Response.</span>statusCodes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unirest.parsers">module unirest.parsers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.parsers.json">
            function <span class="apidocSignatureSpan">unirest.parsers.</span>json
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.parsers.string">
            function <span class="apidocSignatureSpan">unirest.parsers.</span>string
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unirest.request">module unirest.request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.request">
            function <span class="apidocSignatureSpan">unirest.</span>request
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request">
            function <span class="apidocSignatureSpan">unirest.request.</span>Request
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.cookie">
            function <span class="apidocSignatureSpan">unirest.request.</span>cookie
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.defaults">
            function <span class="apidocSignatureSpan">unirest.request.</span>defaults
            <span class="apidocSignatureSpan">(options, requester)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.del">
            function <span class="apidocSignatureSpan">unirest.request.</span>del
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.delete">
            function <span class="apidocSignatureSpan">unirest.request.</span>delete
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.forever">
            function <span class="apidocSignatureSpan">unirest.request.</span>forever
            <span class="apidocSignatureSpan">(agentOptions, optionsArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.get">
            function <span class="apidocSignatureSpan">unirest.request.</span>get
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.head">
            function <span class="apidocSignatureSpan">unirest.request.</span>head
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.initParams">
            function <span class="apidocSignatureSpan">unirest.request.</span>initParams
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.jar">
            function <span class="apidocSignatureSpan">unirest.request.</span>jar
            <span class="apidocSignatureSpan">(store)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.patch">
            function <span class="apidocSignatureSpan">unirest.request.</span>patch
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.post">
            function <span class="apidocSignatureSpan">unirest.request.</span>post
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.put">
            function <span class="apidocSignatureSpan">unirest.request.</span>put
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unirest.request.Request">module unirest.request.Request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.Request">
            function <span class="apidocSignatureSpan">unirest.request.</span>Request
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.super_">
            function <span class="apidocSignatureSpan">unirest.request.Request.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unirest.request.Request.</span>defaultProxyHeaderExclusiveList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unirest.request.Request.</span>defaultProxyHeaderWhiteList</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unirest.request.Request.prototype">module unirest.request.Request.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.abort">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.auth">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>auth
            <span class="apidocSignatureSpan">(user, pass, sendImmediately, bearer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.aws">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>aws
            <span class="apidocSignatureSpan">(opts, now)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.debug">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>debug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.destroy">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.enableUnixSocket">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>enableUnixSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.end">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.form">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>form
            <span class="apidocSignatureSpan">(form)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.getHeader">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>getHeader
            <span class="apidocSignatureSpan">(name, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.getNewAgent">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>getNewAgent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.hawk">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>hawk
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.httpSignature">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>httpSignature
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.init">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>init
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.jar">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>jar
            <span class="apidocSignatureSpan">(jar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.json">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>json
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.multipart">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>multipart
            <span class="apidocSignatureSpan">(multipart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.oauth">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>oauth
            <span class="apidocSignatureSpan">(_oauth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.onRequestError">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>onRequestError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.onRequestResponse">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>onRequestResponse
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.pause">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.pipe">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>pipe
            <span class="apidocSignatureSpan">(dest, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.pipeDest">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>pipeDest
            <span class="apidocSignatureSpan">(dest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.qs">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>qs
            <span class="apidocSignatureSpan">(q, clobber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.readResponseBody">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>readResponseBody
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.resume">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.start">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.toJSON">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.request.Request.prototype.write">
            function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unirest.serializers">module unirest.serializers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.serializers.form">
            function <span class="apidocSignatureSpan">unirest.serializers.</span>form
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unirest.serializers.json">
            function <span class="apidocSignatureSpan">unirest.serializers.</span>json
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unirest" id="apidoc.module.unirest">module unirest</a></h1>


    <h2>
        <a href="#apidoc.element.unirest.cookie" id="apidoc.element.unirest.cookie">
        function <span class="apidocSignatureSpan">unirest.</span>cookie
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cookie = function (str) {
  return cookies.parse(str)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var CookieJar = unirest.jar();
CookieJar.add(&#x27;key=value&#x27;, &#x27;/&#x27;); // Cookie string, pathname / url
unirest.get(&#x27;http://mockbin.com/request&#x27;).jar(CookieJar);
```

## unirest.<span class="apidocCodeKeywordSpan">cookie</span>(String)

Creates a cookie, see above for example.

## unirest.request

`mikeal/request` library (the underlying layer of unirest) for direct use.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.delete" id="apidoc.element.unirest.delete">
        function <span class="apidocSignatureSpan">unirest.</span>delete
        <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (uri, headers, body, callback) {
  var $this = {
<span class="apidocCodeCommentSpan">    /**
     * Stream Multipart form-data request
     *
     * @type {Boolean}
     */
</span>    _stream: false,

    /**
     * Container to hold multipart form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _multipart: [],

    /**
     * Container to hold form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _form: [],

    /**
     * Request option container for details about the request.
     *
     * @type {Object}
     */
    options: {
      /**
       * Url obtained from request method arguments.
       *
       * @type {String}
       */
      url: uri,

      /**
       * Method obtained from request method arguments.
       *
       * @type {String}
       */
      method: method,

      /**
       * List of headers with case-sensitive fields.
       *
       * @type {Object}
       */
      headers: {}
    },

    hasHeader: function (name) {
      var headers
      var lowercaseHeaders

      name = name.toLowerCase()
      headers = Object.keys($this.options.headers)
      lowercaseHeaders = headers.map(function (header) {
        return header.toLowerCase()
      })

      for (var i = 0; i &#x3c; lowercaseHeaders.length; i++) {
        if (lowercaseHeaders[i] === name) {
          return headers[i]
        }
      }

      return false
    },

    /**
     * Turn on multipart-form streaming
     *
     * @return {Object}
     */
    stream: function () {
      $this._stream = true
      return this
    },

    /**
     * Attaches a field to the multipart-form request, with pre-processing.
     *
     * @param  {String} name
     * @param  {String} value
     * @return {Object}
     */
    field: function (name, value, options) {
      return handleField(name, value, options)
    },

    /**
     * Attaches a file to the multipart-form request.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @return {Object}
     */
    attach: function (name, path, options) {
      options = options || {}
      options.attachment = true
      return handleField(name, path, options)
    },

    /**
     * Attaches field to the multipart-form request, with no pre-processing.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @param  {Object} options
     * @return {Object}
     */
    rawField: function (name, value, options) {
      $this._multipart.push({
        name: name,
        value: value,
        options: options,
        attachment: options.attachment || false
      })
    },

    /**
     * Basic Header Authentication Method
     *
     * Supports user being an Object to reflect Request
     * Supports user, password to reflect SuperAgent
     *
     * @param  {String|Object} user
     * @param  {String} password
     * @param  {Boolean} sendImmediately
     * @return {Object}
     */
    auth: function (user, password, sendImmediately) {
      $this.options.auth = (is(user).a(Object)) ? user : {
        user: user,
        password: password,
        sendImmediately: sendImmediately
      }

      return $this
    },

    /**
     * Sets header field to value
     *
     * @param  {String} field Header field
     * @param  {String} value Header field value
     * @return {Object}
     */
    header: function (field, value) {
      if (is(field).a(Object)) {
        for (var key in field) {
          if (field.hasOwnProperty(key)) {
            $this.header(key, field[key])
          }
        }

        return $this
      }

      var existingHeaderName = $this.hasHeader(field)
      $this.options.headers[existingHeaderName || field] = value

      return $this
    },

    /**
     * Serialize value as querystring representation, and append or set on `Request.options.url`
     *
     * @param  {String|Object} value
     * @return {Object}
     */
    query: function (value) {
      if (is(value).a(Object)) value = Unirest.serializers.form(value)
      if (!value.length) return $this
      $this.options.url += (does($this.o ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Request = unirest.patch(&#x27;http://mockbin.com/request&#x27;);
```

### delete
Returns a [Request](#request) object with the `method` option set to `DELETE`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">delete</span>(&#x27;http://mockbin.com/request&#x27;);
```

## unirest.jar()

Creates a container to store multiple cookies, i.e. a cookie jar.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.firstMatch" id="apidoc.element.unirest.firstMatch">
        function <span class="apidocSignatureSpan">unirest.</span>firstMatch
        <span class="apidocSignatureSpan">(string, map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function firstMatch(string, map) {
  return Unirest.matches(string, map)[0]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Unirest Request Utility Methods
 *
 * @type {Object}
 */
Unirest.Request = {
serialize: function (string, type) {
  var serializer = Unirest.<span class="apidocCodeKeywordSpan">firstMatch</span>(type, Unirest.enum.serialize)
  return serializer ? serializer(string) : string
},

uid: function (len) {
  var output = &#x27;&#x27;
  var chars = &#x27;abcdefghijklmnopqrstuvwxyz123456789&#x27;
  var nchars = chars.length
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.get" id="apidoc.element.unirest.get">
        function <span class="apidocSignatureSpan">unirest.</span>get
        <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (uri, headers, body, callback) {
  var $this = {
<span class="apidocCodeCommentSpan">    /**
     * Stream Multipart form-data request
     *
     * @type {Boolean}
     */
</span>    _stream: false,

    /**
     * Container to hold multipart form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _multipart: [],

    /**
     * Container to hold form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _form: [],

    /**
     * Request option container for details about the request.
     *
     * @type {Object}
     */
    options: {
      /**
       * Url obtained from request method arguments.
       *
       * @type {String}
       */
      url: uri,

      /**
       * Method obtained from request method arguments.
       *
       * @type {String}
       */
      method: method,

      /**
       * List of headers with case-sensitive fields.
       *
       * @type {Object}
       */
      headers: {}
    },

    hasHeader: function (name) {
      var headers
      var lowercaseHeaders

      name = name.toLowerCase()
      headers = Object.keys($this.options.headers)
      lowercaseHeaders = headers.map(function (header) {
        return header.toLowerCase()
      })

      for (var i = 0; i &#x3c; lowercaseHeaders.length; i++) {
        if (lowercaseHeaders[i] === name) {
          return headers[i]
        }
      }

      return false
    },

    /**
     * Turn on multipart-form streaming
     *
     * @return {Object}
     */
    stream: function () {
      $this._stream = true
      return this
    },

    /**
     * Attaches a field to the multipart-form request, with pre-processing.
     *
     * @param  {String} name
     * @param  {String} value
     * @return {Object}
     */
    field: function (name, value, options) {
      return handleField(name, value, options)
    },

    /**
     * Attaches a file to the multipart-form request.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @return {Object}
     */
    attach: function (name, path, options) {
      options = options || {}
      options.attachment = true
      return handleField(name, path, options)
    },

    /**
     * Attaches field to the multipart-form request, with no pre-processing.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @param  {Object} options
     * @return {Object}
     */
    rawField: function (name, value, options) {
      $this._multipart.push({
        name: name,
        value: value,
        options: options,
        attachment: options.attachment || false
      })
    },

    /**
     * Basic Header Authentication Method
     *
     * Supports user being an Object to reflect Request
     * Supports user, password to reflect SuperAgent
     *
     * @param  {String|Object} user
     * @param  {String} password
     * @param  {Boolean} sendImmediately
     * @return {Object}
     */
    auth: function (user, password, sendImmediately) {
      $this.options.auth = (is(user).a(Object)) ? user : {
        user: user,
        password: password,
        sendImmediately: sendImmediately
      }

      return $this
    },

    /**
     * Sets header field to value
     *
     * @param  {String} field Header field
     * @param  {String} value Header field value
     * @return {Object}
     */
    header: function (field, value) {
      if (is(field).a(Object)) {
        for (var key in field) {
          if (field.hasOwnProperty(key)) {
            $this.header(key, field[key])
          }
        }

        return $this
      }

      var existingHeaderName = $this.hasHeader(field)
      $this.options.headers[existingHeaderName || field] = value

      return $this
    },

    /**
     * Serialize value as querystring representation, and append or set on `Request.options.url`
     *
     * @param  {String|Object} value
     * @return {Object}
     */
    query: function (value) {
      if (is(value).a(Object)) value = Unirest.serializers.form(value)
      if (!value.length) return $this
      $this.options.url += (does($this.o ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
When no `callback` is present, the [Request](#request) object will be returned.

### get

Returns a [Request](#request) object with the `method` option set to `GET`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">get</span>(&#x27;http://mockbin.com/request&#x27;);
```

### head
Returns a [Request](#request) object with the `method` option set to `HEAD`

```js
var Request = unirest.head(&#x27;http://mockbin.com/request&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.head" id="apidoc.element.unirest.head">
        function <span class="apidocSignatureSpan">unirest.</span>head
        <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function (uri, headers, body, callback) {
  var $this = {
<span class="apidocCodeCommentSpan">    /**
     * Stream Multipart form-data request
     *
     * @type {Boolean}
     */
</span>    _stream: false,

    /**
     * Container to hold multipart form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _multipart: [],

    /**
     * Container to hold form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _form: [],

    /**
     * Request option container for details about the request.
     *
     * @type {Object}
     */
    options: {
      /**
       * Url obtained from request method arguments.
       *
       * @type {String}
       */
      url: uri,

      /**
       * Method obtained from request method arguments.
       *
       * @type {String}
       */
      method: method,

      /**
       * List of headers with case-sensitive fields.
       *
       * @type {Object}
       */
      headers: {}
    },

    hasHeader: function (name) {
      var headers
      var lowercaseHeaders

      name = name.toLowerCase()
      headers = Object.keys($this.options.headers)
      lowercaseHeaders = headers.map(function (header) {
        return header.toLowerCase()
      })

      for (var i = 0; i &#x3c; lowercaseHeaders.length; i++) {
        if (lowercaseHeaders[i] === name) {
          return headers[i]
        }
      }

      return false
    },

    /**
     * Turn on multipart-form streaming
     *
     * @return {Object}
     */
    stream: function () {
      $this._stream = true
      return this
    },

    /**
     * Attaches a field to the multipart-form request, with pre-processing.
     *
     * @param  {String} name
     * @param  {String} value
     * @return {Object}
     */
    field: function (name, value, options) {
      return handleField(name, value, options)
    },

    /**
     * Attaches a file to the multipart-form request.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @return {Object}
     */
    attach: function (name, path, options) {
      options = options || {}
      options.attachment = true
      return handleField(name, path, options)
    },

    /**
     * Attaches field to the multipart-form request, with no pre-processing.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @param  {Object} options
     * @return {Object}
     */
    rawField: function (name, value, options) {
      $this._multipart.push({
        name: name,
        value: value,
        options: options,
        attachment: options.attachment || false
      })
    },

    /**
     * Basic Header Authentication Method
     *
     * Supports user being an Object to reflect Request
     * Supports user, password to reflect SuperAgent
     *
     * @param  {String|Object} user
     * @param  {String} password
     * @param  {Boolean} sendImmediately
     * @return {Object}
     */
    auth: function (user, password, sendImmediately) {
      $this.options.auth = (is(user).a(Object)) ? user : {
        user: user,
        password: password,
        sendImmediately: sendImmediately
      }

      return $this
    },

    /**
     * Sets header field to value
     *
     * @param  {String} field Header field
     * @param  {String} value Header field value
     * @return {Object}
     */
    header: function (field, value) {
      if (is(field).a(Object)) {
        for (var key in field) {
          if (field.hasOwnProperty(key)) {
            $this.header(key, field[key])
          }
        }

        return $this
      }

      var existingHeaderName = $this.hasHeader(field)
      $this.options.headers[existingHeaderName || field] = value

      return $this
    },

    /**
     * Serialize value as querystring representation, and append or set on `Request.options.url`
     *
     * @param  {String|Object} value
     * @return {Object}
     */
    query: function (value) {
      if (is(value).a(Object)) value = Unirest.serializers.form(value)
      if (!value.length) return $this
      $this.options.url += (does($this.o ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Request = unirest.get(&#x27;http://mockbin.com/request&#x27;);
```

### head
Returns a [Request](#request) object with the `method` option set to `HEAD`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">head</span>(&#x27;http://mockbin.com/request&#x27;);
```

### put
Returns a [Request](#request) object with the `method` option set to `PUT`

```js
var Request = unirest.put(&#x27;http://mockbin.com/request&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.jar" id="apidoc.element.unirest.jar">
        function <span class="apidocSignatureSpan">unirest.</span>jar
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jar = function (options) {
  var jar = Unirest.request.jar()
  options = options || {}

  // Because Requests aliases toughcookie rather than returning.
  if (options.store) {
    jar._jar.store = options.store
  }

  if (options.rejectPublicSuffixes) {
    jar._jar.rejectPublicSuffixes = options.rejectPublicSuffixes
  }

  // Alias helper methods
  jar.add = jar.setCookie
  jar.toString = jar.getCookieString

  // Export
  return jar
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### delete
Returns a [Request](#request) object with the `method` option set to `DELETE`

```js
var Request = unirest.delete(&#x27;http://mockbin.com/request&#x27;);
```

## unirest.<span class="apidocCodeKeywordSpan">jar</span>()

Creates a container to store multiple cookies, i.e. a cookie jar.

```js
var CookieJar = unirest.jar();
CookieJar.add(&#x27;key=value&#x27;, &#x27;/&#x27;); // Cookie string, pathname / url
unirest.get(&#x27;http://mockbin.com/request&#x27;).jar(CookieJar);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.matches" id="apidoc.element.unirest.matches">
        function <span class="apidocSignatureSpan">unirest.</span>matches
        <span class="apidocSignatureSpan">(string, map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matches(string, map) {
  var results = []

  for (var key in map) {
    if (typeof map.length !== &#x27;undefined&#x27;) {
      key = map[key]
    }

    if (string.indexOf(key) !== -1) {
      results.push(map[key])
    }
  }

  return results
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @see #matches
* @param  {String} string String to be tested
* @param  {Object|Array} map Values / Keys to test against string.
* @return {Mixed} First match value
*/
Unirest.firstMatch = function firstMatch (string, map) {
 return Unirest.<span class="apidocCodeKeywordSpan">matches</span>(string, map)[0]
}

/**
* Generate sugar for request library.
*
* This allows us to mock super-agent chaining style while using request library under the hood.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.options" id="apidoc.element.unirest.options">
        function <span class="apidocSignatureSpan">unirest.</span>options
        <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">options = function (uri, headers, body, callback) {
  var $this = {
<span class="apidocCodeCommentSpan">    /**
     * Stream Multipart form-data request
     *
     * @type {Boolean}
     */
</span>    _stream: false,

    /**
     * Container to hold multipart form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _multipart: [],

    /**
     * Container to hold form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _form: [],

    /**
     * Request option container for details about the request.
     *
     * @type {Object}
     */
    options: {
      /**
       * Url obtained from request method arguments.
       *
       * @type {String}
       */
      url: uri,

      /**
       * Method obtained from request method arguments.
       *
       * @type {String}
       */
      method: method,

      /**
       * List of headers with case-sensitive fields.
       *
       * @type {Object}
       */
      headers: {}
    },

    hasHeader: function (name) {
      var headers
      var lowercaseHeaders

      name = name.toLowerCase()
      headers = Object.keys($this.options.headers)
      lowercaseHeaders = headers.map(function (header) {
        return header.toLowerCase()
      })

      for (var i = 0; i &#x3c; lowercaseHeaders.length; i++) {
        if (lowercaseHeaders[i] === name) {
          return headers[i]
        }
      }

      return false
    },

    /**
     * Turn on multipart-form streaming
     *
     * @return {Object}
     */
    stream: function () {
      $this._stream = true
      return this
    },

    /**
     * Attaches a field to the multipart-form request, with pre-processing.
     *
     * @param  {String} name
     * @param  {String} value
     * @return {Object}
     */
    field: function (name, value, options) {
      return handleField(name, value, options)
    },

    /**
     * Attaches a file to the multipart-form request.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @return {Object}
     */
    attach: function (name, path, options) {
      options = options || {}
      options.attachment = true
      return handleField(name, path, options)
    },

    /**
     * Attaches field to the multipart-form request, with no pre-processing.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @param  {Object} options
     * @return {Object}
     */
    rawField: function (name, value, options) {
      $this._multipart.push({
        name: name,
        value: value,
        options: options,
        attachment: options.attachment || false
      })
    },

    /**
     * Basic Header Authentication Method
     *
     * Supports user being an Object to reflect Request
     * Supports user, password to reflect SuperAgent
     *
     * @param  {String|Object} user
     * @param  {String} password
     * @param  {Boolean} sendImmediately
     * @return {Object}
     */
    auth: function (user, password, sendImmediately) {
      $this.options.auth = (is(user).a(Object)) ? user : {
        user: user,
        password: password,
        sendImmediately: sendImmediately
      }

      return $this
    },

    /**
     * Sets header field to value
     *
     * @param  {String} field Header field
     * @param  {String} value Header field value
     * @return {Object}
     */
    header: function (field, value) {
      if (is(field).a(Object)) {
        for (var key in field) {
          if (field.hasOwnProperty(key)) {
            $this.header(key, field[key])
          }
        }

        return $this
      }

      var existingHeaderName = $this.hasHeader(field)
      $this.options.headers[existingHeaderName || field] = value

      return $this
    },

    /**
     * Serialize value as querystring representation, and append or set on `Request.options.url`
     *
     * @param  {String|Object} value
     * @return {Object}
     */
    query: function (value) {
      if (is(value).a(Object)) value = Unirest.serializers.form(value)
      if (!value.length) return $this
      $this.options.url += (does($this.o ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.patch" id="apidoc.element.unirest.patch">
        function <span class="apidocSignatureSpan">unirest.</span>patch
        <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patch = function (uri, headers, body, callback) {
  var $this = {
<span class="apidocCodeCommentSpan">    /**
     * Stream Multipart form-data request
     *
     * @type {Boolean}
     */
</span>    _stream: false,

    /**
     * Container to hold multipart form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _multipart: [],

    /**
     * Container to hold form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _form: [],

    /**
     * Request option container for details about the request.
     *
     * @type {Object}
     */
    options: {
      /**
       * Url obtained from request method arguments.
       *
       * @type {String}
       */
      url: uri,

      /**
       * Method obtained from request method arguments.
       *
       * @type {String}
       */
      method: method,

      /**
       * List of headers with case-sensitive fields.
       *
       * @type {Object}
       */
      headers: {}
    },

    hasHeader: function (name) {
      var headers
      var lowercaseHeaders

      name = name.toLowerCase()
      headers = Object.keys($this.options.headers)
      lowercaseHeaders = headers.map(function (header) {
        return header.toLowerCase()
      })

      for (var i = 0; i &#x3c; lowercaseHeaders.length; i++) {
        if (lowercaseHeaders[i] === name) {
          return headers[i]
        }
      }

      return false
    },

    /**
     * Turn on multipart-form streaming
     *
     * @return {Object}
     */
    stream: function () {
      $this._stream = true
      return this
    },

    /**
     * Attaches a field to the multipart-form request, with pre-processing.
     *
     * @param  {String} name
     * @param  {String} value
     * @return {Object}
     */
    field: function (name, value, options) {
      return handleField(name, value, options)
    },

    /**
     * Attaches a file to the multipart-form request.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @return {Object}
     */
    attach: function (name, path, options) {
      options = options || {}
      options.attachment = true
      return handleField(name, path, options)
    },

    /**
     * Attaches field to the multipart-form request, with no pre-processing.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @param  {Object} options
     * @return {Object}
     */
    rawField: function (name, value, options) {
      $this._multipart.push({
        name: name,
        value: value,
        options: options,
        attachment: options.attachment || false
      })
    },

    /**
     * Basic Header Authentication Method
     *
     * Supports user being an Object to reflect Request
     * Supports user, password to reflect SuperAgent
     *
     * @param  {String|Object} user
     * @param  {String} password
     * @param  {Boolean} sendImmediately
     * @return {Object}
     */
    auth: function (user, password, sendImmediately) {
      $this.options.auth = (is(user).a(Object)) ? user : {
        user: user,
        password: password,
        sendImmediately: sendImmediately
      }

      return $this
    },

    /**
     * Sets header field to value
     *
     * @param  {String} field Header field
     * @param  {String} value Header field value
     * @return {Object}
     */
    header: function (field, value) {
      if (is(field).a(Object)) {
        for (var key in field) {
          if (field.hasOwnProperty(key)) {
            $this.header(key, field[key])
          }
        }

        return $this
      }

      var existingHeaderName = $this.hasHeader(field)
      $this.options.headers[existingHeaderName || field] = value

      return $this
    },

    /**
     * Serialize value as querystring representation, and append or set on `Request.options.url`
     *
     * @param  {String|Object} value
     * @return {Object}
     */
    query: function (value) {
      if (is(value).a(Object)) value = Unirest.serializers.form(value)
      if (!value.length) return $this
      $this.options.url += (does($this.o ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### patch

Returns a [Request](#request) object with the `method` option set to `PATCH`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">patch</span>(&#x27;http://mockbin.com/request&#x27;);
```

### delete
Returns a [Request](#request) object with the `method` option set to `DELETE`

```js
var Request = unirest.delete(&#x27;http://mockbin.com/request&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.post" id="apidoc.element.unirest.post">
        function <span class="apidocSignatureSpan">unirest.</span>post
        <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (uri, headers, body, callback) {
  var $this = {
<span class="apidocCodeCommentSpan">    /**
     * Stream Multipart form-data request
     *
     * @type {Boolean}
     */
</span>    _stream: false,

    /**
     * Container to hold multipart form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _multipart: [],

    /**
     * Container to hold form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _form: [],

    /**
     * Request option container for details about the request.
     *
     * @type {Object}
     */
    options: {
      /**
       * Url obtained from request method arguments.
       *
       * @type {String}
       */
      url: uri,

      /**
       * Method obtained from request method arguments.
       *
       * @type {String}
       */
      method: method,

      /**
       * List of headers with case-sensitive fields.
       *
       * @type {Object}
       */
      headers: {}
    },

    hasHeader: function (name) {
      var headers
      var lowercaseHeaders

      name = name.toLowerCase()
      headers = Object.keys($this.options.headers)
      lowercaseHeaders = headers.map(function (header) {
        return header.toLowerCase()
      })

      for (var i = 0; i &#x3c; lowercaseHeaders.length; i++) {
        if (lowercaseHeaders[i] === name) {
          return headers[i]
        }
      }

      return false
    },

    /**
     * Turn on multipart-form streaming
     *
     * @return {Object}
     */
    stream: function () {
      $this._stream = true
      return this
    },

    /**
     * Attaches a field to the multipart-form request, with pre-processing.
     *
     * @param  {String} name
     * @param  {String} value
     * @return {Object}
     */
    field: function (name, value, options) {
      return handleField(name, value, options)
    },

    /**
     * Attaches a file to the multipart-form request.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @return {Object}
     */
    attach: function (name, path, options) {
      options = options || {}
      options.attachment = true
      return handleField(name, path, options)
    },

    /**
     * Attaches field to the multipart-form request, with no pre-processing.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @param  {Object} options
     * @return {Object}
     */
    rawField: function (name, value, options) {
      $this._multipart.push({
        name: name,
        value: value,
        options: options,
        attachment: options.attachment || false
      })
    },

    /**
     * Basic Header Authentication Method
     *
     * Supports user being an Object to reflect Request
     * Supports user, password to reflect SuperAgent
     *
     * @param  {String|Object} user
     * @param  {String} password
     * @param  {Boolean} sendImmediately
     * @return {Object}
     */
    auth: function (user, password, sendImmediately) {
      $this.options.auth = (is(user).a(Object)) ? user : {
        user: user,
        password: password,
        sendImmediately: sendImmediately
      }

      return $this
    },

    /**
     * Sets header field to value
     *
     * @param  {String} field Header field
     * @param  {String} value Header field value
     * @return {Object}
     */
    header: function (field, value) {
      if (is(field).a(Object)) {
        for (var key in field) {
          if (field.hasOwnProperty(key)) {
            $this.header(key, field[key])
          }
        }

        return $this
      }

      var existingHeaderName = $this.hasHeader(field)
      $this.options.headers[existingHeaderName || field] = value

      return $this
    },

    /**
     * Serialize value as querystring representation, and append or set on `Request.options.url`
     *
     * @param  {String|Object} value
     * @return {Object}
     */
    query: function (value) {
      if (is(value).a(Object)) value = Unirest.serializers.form(value)
      if (!value.length) return $this
      $this.options.url += (does($this.o ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

## Creating Requests

You&#x27;re probably wondering how by using **Unirest** makes creating requests easier. Besides automatically supporting gzip, and
 parsing responses, lets start with a basic working example:

```js
unirest.<span class="apidocCodeKeywordSpan">post</span>(&#x27;http://mockbin.com/request&#x27;)
.headers({&#x27;Accept&#x27;: &#x27;application/json&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;})
.send({ &#x22;parameter&#x22;: 23, &#x22;foo&#x22;: &#x22;bar&#x22; })
.end(function (response) {
  console.log(response.body);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.put" id="apidoc.element.unirest.put">
        function <span class="apidocSignatureSpan">unirest.</span>put
        <span class="apidocSignatureSpan">(uri, headers, body, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">put = function (uri, headers, body, callback) {
  var $this = {
<span class="apidocCodeCommentSpan">    /**
     * Stream Multipart form-data request
     *
     * @type {Boolean}
     */
</span>    _stream: false,

    /**
     * Container to hold multipart form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _multipart: [],

    /**
     * Container to hold form data for processing upon request.
     *
     * @type {Array}
     * @private
     */
    _form: [],

    /**
     * Request option container for details about the request.
     *
     * @type {Object}
     */
    options: {
      /**
       * Url obtained from request method arguments.
       *
       * @type {String}
       */
      url: uri,

      /**
       * Method obtained from request method arguments.
       *
       * @type {String}
       */
      method: method,

      /**
       * List of headers with case-sensitive fields.
       *
       * @type {Object}
       */
      headers: {}
    },

    hasHeader: function (name) {
      var headers
      var lowercaseHeaders

      name = name.toLowerCase()
      headers = Object.keys($this.options.headers)
      lowercaseHeaders = headers.map(function (header) {
        return header.toLowerCase()
      })

      for (var i = 0; i &#x3c; lowercaseHeaders.length; i++) {
        if (lowercaseHeaders[i] === name) {
          return headers[i]
        }
      }

      return false
    },

    /**
     * Turn on multipart-form streaming
     *
     * @return {Object}
     */
    stream: function () {
      $this._stream = true
      return this
    },

    /**
     * Attaches a field to the multipart-form request, with pre-processing.
     *
     * @param  {String} name
     * @param  {String} value
     * @return {Object}
     */
    field: function (name, value, options) {
      return handleField(name, value, options)
    },

    /**
     * Attaches a file to the multipart-form request.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @return {Object}
     */
    attach: function (name, path, options) {
      options = options || {}
      options.attachment = true
      return handleField(name, path, options)
    },

    /**
     * Attaches field to the multipart-form request, with no pre-processing.
     *
     * @param  {String} name
     * @param  {String|Object} path
     * @param  {Object} options
     * @return {Object}
     */
    rawField: function (name, value, options) {
      $this._multipart.push({
        name: name,
        value: value,
        options: options,
        attachment: options.attachment || false
      })
    },

    /**
     * Basic Header Authentication Method
     *
     * Supports user being an Object to reflect Request
     * Supports user, password to reflect SuperAgent
     *
     * @param  {String|Object} user
     * @param  {String} password
     * @param  {Boolean} sendImmediately
     * @return {Object}
     */
    auth: function (user, password, sendImmediately) {
      $this.options.auth = (is(user).a(Object)) ? user : {
        user: user,
        password: password,
        sendImmediately: sendImmediately
      }

      return $this
    },

    /**
     * Sets header field to value
     *
     * @param  {String} field Header field
     * @param  {String} value Header field value
     * @return {Object}
     */
    header: function (field, value) {
      if (is(field).a(Object)) {
        for (var key in field) {
          if (field.hasOwnProperty(key)) {
            $this.header(key, field[key])
          }
        }

        return $this
      }

      var existingHeaderName = $this.hasHeader(field)
      $this.options.headers[existingHeaderName || field] = value

      return $this
    },

    /**
     * Serialize value as querystring representation, and append or set on `Request.options.url`
     *
     * @param  {String|Object} value
     * @return {Object}
     */
    query: function (value) {
      if (is(value).a(Object)) value = Unirest.serializers.form(value)
      if (!value.length) return $this
      $this.options.url += (does($this.o ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Request = unirest.head(&#x27;http://mockbin.com/request&#x27;);
```

### put
Returns a [Request](#request) object with the `method` option set to `PUT`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">put</span>(&#x27;http://mockbin.com/request&#x27;);
```

### post
Returns a [Request](#request) object with the `method` option set to `POST`

```js
var Request = unirest.post(&#x27;http://mockbin.com/request&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request" id="apidoc.element.unirest.request">
        function <span class="apidocSignatureSpan">unirest.</span>request
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function request(uri, options, callback) {
  if (typeof uri === &#x27;undefined&#x27;) {
    throw new Error(&#x27;undefined is not a valid uri or options object.&#x27;)
  }

  var params = initParams(uri, options, callback)

  if (params.method === &#x27;HEAD&#x27; &#x26;&#x26; paramsHaveRequestBody(params)) {
    throw new Error(&#x27;HTTP HEAD requests MUST NOT include a request body.&#x27;)
  }

  return new request.Request(params)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.header(&#x27;Accept&#x27;, &#x27;application/json&#x27;)
.field({
  &#x27;parameter&#x27;: &#x27;value&#x27;
})
.attach({
  &#x27;file&#x27;: &#x27;dog.png&#x27;,
  &#x27;relative file&#x27;: fs.createReadStream(path.join(__dirname, &#x27;dog.png&#x27;)),
  &#x27;remote file&#x27;: unirest.<span class="apidocCodeKeywordSpan">request</span>(&#x27;http://google.com/doodle.png&#x27;)
})
.end(function (response) {
  console.log(response.body);
})
```

**Arguments**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request" id="apidoc.element.unirest.request.Request">
        function <span class="apidocSignatureSpan">unirest.</span>request.Request
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Request(options) {
  // if given the method property in options, set property explicitMethod to true

  // extend the Request instance with any non-reserved properties
  // remove any reserved functions from the options object
  // set Request instance to be readable and writable
  // call init

  var self = this

  // start with HAR, then override with additional options
  if (options.har) {
    self._har = new Har(self)
    options = self._har.options(options)
  }

  stream.Stream.call(self)
  var reserved = Object.keys(Request.prototype)
  var nonReserved = filterForNonReserved(reserved, options)

  extend(self, nonReserved)
  options = filterOutReservedFunctions(reserved, options)

  self.readable = true
  self.writable = true
  if (options.method) {
    self.explicitMethod = true
  }
  self._qs = new Querystring(self)
  self._auth = new Auth(self)
  self._oauth = new OAuth(self)
  self._multipart = new Multipart(self)
  self._redirect = new Redirect(self)
  self._tunnel = new Tunnel(self)
  self.init(options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.trim" id="apidoc.element.unirest.trim">
        function <span class="apidocSignatureSpan">unirest.</span>trim
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trim = function (s) { return s.trim() }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Cookie Sugar Method
result.cookie = function (name) {
  return result.cookies[name]
}

function setCookie (cookie) {
  var crumbs = Unirest.<span class="apidocCodeKeywordSpan">trim</span>(cookie).split(&#x27;=&#x27;)
  var key = Unirest.trim(crumbs[0])
  var value = Unirest.trim(crumbs.slice(1).join(&#x27;=&#x27;))

  if (crumbs[0] &#x26;&#x26; crumbs[0] !== &#x27;&#x27;) {
    result.cookies[key] = value === &#x27;&#x27; ? true : value
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.type" id="apidoc.element.unirest.type">
        function <span class="apidocSignatureSpan">unirest.</span>type
        <span class="apidocSignatureSpan">(type, parse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function (type, parse) {
  if (typeof type !== &#x27;string&#x27;) return false
  return parse ? type.split(/ *; */).shift() : (Unirest.types[type] || type)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

#### Request.send(Object | String)

Data marshalling for HTTP request body data

Determines whether data mime-type is `form` or `json`.
For irregular mime-types the `.<span class="apidocCodeKeywordSpan">type</span>()` method is used to infer the `content-type` header
.

When mime-type is `application/x-www-form-urlencoded` data is appended rather than overwritten.

**JSON**

```js
unirest.post(&#x27;http://mockbin.com/request&#x27;)
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unirest.Request" id="apidoc.module.unirest.Request">module unirest.Request</a></h1>


    <h2>
        <a href="#apidoc.element.unirest.Request.serialize" id="apidoc.element.unirest.Request.serialize">
        function <span class="apidocSignatureSpan">unirest.Request.</span>serialize
        <span class="apidocSignatureSpan">(string, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function (string, type) {
  var serializer = Unirest.firstMatch(type, Unirest.enum.serialize)
  return serializer ? serializer(string) : string
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          $this.options.body[key] = data[key]
        }
      }
    } else {
      $this.options.body = data
    }
  } else {
    $this.options.body = Unirest.Request.<span class="apidocCodeKeywordSpan">serialize</span>(data, type)
  }
} else if (is(data).a(String)) {
  if (!type) {
    $this.type(&#x27;form&#x27;)
    type = $this.options.headers[$this.hasHeader(&#x27;content-type&#x27;)]
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.Request.uid" id="apidoc.element.unirest.Request.uid">
        function <span class="apidocSignatureSpan">unirest.Request.</span>uid
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uid = function (len) {
  var output = &#x27;&#x27;
  var chars = &#x27;abcdefghijklmnopqrstuvwxyz123456789&#x27;
  var nchars = chars.length
  while (len--) output += chars[Math.random() * nchars | 0]
  return output
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unirest.Response" id="apidoc.module.unirest.Response">module unirest.Response</a></h1>


    <h2>
        <a href="#apidoc.element.unirest.Response.parse" id="apidoc.element.unirest.Response.parse">
        function <span class="apidocSignatureSpan">unirest.Response.</span>parse
        <span class="apidocSignatureSpan">(string, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (string, type) {
  var parser = Unirest.firstMatch(type, Unirest.enum.parse)
  return parser ? parser(string) : string
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The _options_ `object` is where almost all of the request settings live. Each option method sugars to a field on this object to
allow for chaining and ease of use. If
you have trouble with an option method and wish to directly access the _options_ object
you are free to do so.

This object is modeled after the `request` libraries options that are passed along through its constructor.

* `url` (`String` | `Object`) - Url, or object parsed from `url.<span class="apidocCodeKeywordSpan">parse</span>()`
* `qs` (`Object`) - Object consisting of `querystring` values to append to `url` upon request.
* `method` (`String`) - Default `GET`; HTTP Method.
* `headers` (`Object`) - Default `{}`; HTTP Headers.
* `body` (`String` | `Object`) - Entity body for certain requests.
* `form` (`Object`) - Form data.
* `auth` (`Object`) - See `Request.auth()` below.
* `multipart` (`Object`) - _Experimental_; See documentation below.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.Response.parseHeader" id="apidoc.element.unirest.Response.parseHeader">
        function <span class="apidocSignatureSpan">unirest.Response.</span>parseHeader
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseHeader = function (str) {
  var lines = str.split(/\r?\n/)
  var fields = {}
  var index
  var line
  var field
  var val

  // Trailing CRLF
  lines.pop()

  for (var i = 0, len = lines.length; i &#x3c; len; ++i) {
    line = lines[i]
    index = line.indexOf(&#x27;:&#x27;)
    field = line.slice(0, index).toLowerCase()
    val = Unirest.trim(line.slice(index + 1))
    fields[field] = val
  }

  return fields
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unirest.parsers" id="apidoc.module.unirest.parsers">module unirest.parsers</a></h1>


    <h2>
        <a href="#apidoc.element.unirest.parsers.json" id="apidoc.element.unirest.parsers.json">
        function <span class="apidocSignatureSpan">unirest.parsers.</span>json
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (data) {
  try {
    data = JSON.parse(data)
  } catch (e) {}

  return data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (is(options).a(Object)) {
  if (options[&#x27;content-type&#x27;]) {
    var type = Unirest.type(options[&#x27;content-type&#x27;], true)
    if (type) options.body = Unirest.Response.parse(options.body)
  } else {
    if (is(options.body).a(Object)) {
      options.body = Unirest.serializers.<span class="apidocCodeKeywordSpan">json</span>(options.body)
    }
  }

  $this.options.multipart.push(options)
} else {
  $this.options.multipart.push({
    body: options
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.parsers.string" id="apidoc.element.unirest.parsers.string">
        function <span class="apidocSignatureSpan">unirest.parsers.</span>string
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string = function (data) {
  var obj = {}
  var pairs = data.split(&#x27;&#x26;&#x27;)
  var parts
  var pair

  for (var i = 0, len = pairs.length; i &#x3c; len; ++i) {
    pair = pairs[i]
    parts = pair.split(&#x27;=&#x27;)
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1])
  }

  return obj
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unirest.request" id="apidoc.module.unirest.request">module unirest.request</a></h1>


    <h2>
        <a href="#apidoc.element.unirest.request.request" id="apidoc.element.unirest.request.request">
        function <span class="apidocSignatureSpan">unirest.</span>request
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function request(uri, options, callback) {
  if (typeof uri === &#x27;undefined&#x27;) {
    throw new Error(&#x27;undefined is not a valid uri or options object.&#x27;)
  }

  var params = initParams(uri, options, callback)

  if (params.method === &#x27;HEAD&#x27; &#x26;&#x26; paramsHaveRequestBody(params)) {
    throw new Error(&#x27;HTTP HEAD requests MUST NOT include a request body.&#x27;)
  }

  return new request.Request(params)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.header(&#x27;Accept&#x27;, &#x27;application/json&#x27;)
.field({
  &#x27;parameter&#x27;: &#x27;value&#x27;
})
.attach({
  &#x27;file&#x27;: &#x27;dog.png&#x27;,
  &#x27;relative file&#x27;: fs.createReadStream(path.join(__dirname, &#x27;dog.png&#x27;)),
  &#x27;remote file&#x27;: unirest.<span class="apidocCodeKeywordSpan">request</span>(&#x27;http://google.com/doodle.png&#x27;)
})
.end(function (response) {
  console.log(response.body);
})
```

**Arguments**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request" id="apidoc.element.unirest.request.Request">
        function <span class="apidocSignatureSpan">unirest.request.</span>Request
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Request(options) {
  // if given the method property in options, set property explicitMethod to true

  // extend the Request instance with any non-reserved properties
  // remove any reserved functions from the options object
  // set Request instance to be readable and writable
  // call init

  var self = this

  // start with HAR, then override with additional options
  if (options.har) {
    self._har = new Har(self)
    options = self._har.options(options)
  }

  stream.Stream.call(self)
  var reserved = Object.keys(Request.prototype)
  var nonReserved = filterForNonReserved(reserved, options)

  extend(self, nonReserved)
  options = filterOutReservedFunctions(reserved, options)

  self.readable = true
  self.writable = true
  if (options.method) {
    self.explicitMethod = true
  }
  self._qs = new Querystring(self)
  self._auth = new Auth(self)
  self._oauth = new OAuth(self)
  self._multipart = new Multipart(self)
  self._redirect = new Redirect(self)
  self._tunnel = new Tunnel(self)
  self.init(options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.cookie" id="apidoc.element.unirest.request.cookie">
        function <span class="apidocSignatureSpan">unirest.request.</span>cookie
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cookie = function (str) {
  return cookies.parse(str)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var CookieJar = unirest.jar();
CookieJar.add(&#x27;key=value&#x27;, &#x27;/&#x27;); // Cookie string, pathname / url
unirest.get(&#x27;http://mockbin.com/request&#x27;).jar(CookieJar);
```

## unirest.<span class="apidocCodeKeywordSpan">cookie</span>(String)

Creates a cookie, see above for example.

## unirest.request

`mikeal/request` library (the underlying layer of unirest) for direct use.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.defaults" id="apidoc.element.unirest.request.defaults">
        function <span class="apidocSignatureSpan">unirest.request.</span>defaults
        <span class="apidocSignatureSpan">(options, requester)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (options, requester) {
  var self = this

  options = options || {}

  if (typeof options === &#x27;function&#x27;) {
    requester = options
    options = {}
  }

  var defaults      = wrapRequestMethod(self, options, requester)

  var verbs = [&#x27;get&#x27;, &#x27;head&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;, &#x27;del&#x27;, &#x27;delete&#x27;]
  verbs.forEach(function(verb) {
    defaults[verb]  = wrapRequestMethod(self[verb], options, requester, verb)
  })

  defaults.cookie   = wrapRequestMethod(self.cookie, options, requester)
  defaults.jar      = self.jar
  defaults.defaults = self.defaults
  return defaults
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.del" id="apidoc.element.unirest.request.del">
        function <span class="apidocSignatureSpan">unirest.request.</span>del
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">del = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.method = method
  return request(params, params.callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.delete" id="apidoc.element.unirest.request.delete">
        function <span class="apidocSignatureSpan">unirest.request.</span>delete
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.method = method
  return request(params, params.callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Request = unirest.patch(&#x27;http://mockbin.com/request&#x27;);
```

### delete
Returns a [Request](#request) object with the `method` option set to `DELETE`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">delete</span>(&#x27;http://mockbin.com/request&#x27;);
```

## unirest.jar()

Creates a container to store multiple cookies, i.e. a cookie jar.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.forever" id="apidoc.element.unirest.request.forever">
        function <span class="apidocSignatureSpan">unirest.request.</span>forever
        <span class="apidocSignatureSpan">(agentOptions, optionsArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forever = function (agentOptions, optionsArg) {
  var options = {}
  if (optionsArg) {
    extend(options, optionsArg)
  }
  if (agentOptions) {
    options.agentOptions = agentOptions
  }

  options.forever = true
  return request.defaults(options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `strictSSL` (`Boolean`) - Default `true`; See `Request.strictSSL()` below.
* `secureProtocol` (`String`) - See `Request.secureProtocol()` below.
* `jar` (`Boolean` | `Jar`) - See `Request.jar()` below.
* `aws` (`Object`) - See `Request.aws()` below.
* `httpSignature` (`Object`) - See `Request.httpSignature()` Below.
* `localAddress` (`String`) - See `Request.localAddress()` Below.
* `pool` (`Object`) - See `Request.pool()` Below.
* `forever` (`Boolean`) - Default `undefined`; See `Request.<span class="apidocCodeKeywordSpan">forever</span>()` Below

## Request Option Methods

#### Request.url(String)

Sets `url` location of the current request on `Request.options` to the given `String`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.get" id="apidoc.element.unirest.request.get">
        function <span class="apidocSignatureSpan">unirest.request.</span>get
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.method = method
  return request(params, params.callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
When no `callback` is present, the [Request](#request) object will be returned.

### get

Returns a [Request](#request) object with the `method` option set to `GET`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">get</span>(&#x27;http://mockbin.com/request&#x27;);
```

### head
Returns a [Request](#request) object with the `method` option set to `HEAD`

```js
var Request = unirest.head(&#x27;http://mockbin.com/request&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.head" id="apidoc.element.unirest.request.head">
        function <span class="apidocSignatureSpan">unirest.request.</span>head
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.method = method
  return request(params, params.callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Request = unirest.get(&#x27;http://mockbin.com/request&#x27;);
```

### head
Returns a [Request](#request) object with the `method` option set to `HEAD`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">head</span>(&#x27;http://mockbin.com/request&#x27;);
```

### put
Returns a [Request](#request) object with the `method` option set to `PUT`

```js
var Request = unirest.put(&#x27;http://mockbin.com/request&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.initParams" id="apidoc.element.unirest.request.initParams">
        function <span class="apidocSignatureSpan">unirest.request.</span>initParams
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initParams(uri, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options
  }

  var params = {}
  if (typeof options === &#x27;object&#x27;) {
    extend(params, options, {uri: uri})
  } else if (typeof uri === &#x27;string&#x27;) {
    extend(params, {uri: uri})
  } else {
    extend(params, uri)
  }

  params.callback = callback || params.callback
  return params
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.jar" id="apidoc.element.unirest.request.jar">
        function <span class="apidocSignatureSpan">unirest.request.</span>jar
        <span class="apidocSignatureSpan">(store)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jar = function (store) {
  return cookies.jar(store)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### delete
Returns a [Request](#request) object with the `method` option set to `DELETE`

```js
var Request = unirest.delete(&#x27;http://mockbin.com/request&#x27;);
```

## unirest.<span class="apidocCodeKeywordSpan">jar</span>()

Creates a container to store multiple cookies, i.e. a cookie jar.

```js
var CookieJar = unirest.jar();
CookieJar.add(&#x27;key=value&#x27;, &#x27;/&#x27;); // Cookie string, pathname / url
unirest.get(&#x27;http://mockbin.com/request&#x27;).jar(CookieJar);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.patch" id="apidoc.element.unirest.request.patch">
        function <span class="apidocSignatureSpan">unirest.request.</span>patch
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patch = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.method = method
  return request(params, params.callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### patch

Returns a [Request](#request) object with the `method` option set to `PATCH`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">patch</span>(&#x27;http://mockbin.com/request&#x27;);
```

### delete
Returns a [Request](#request) object with the `method` option set to `DELETE`

```js
var Request = unirest.delete(&#x27;http://mockbin.com/request&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.post" id="apidoc.element.unirest.request.post">
        function <span class="apidocSignatureSpan">unirest.request.</span>post
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.method = method
  return request(params, params.callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

## Creating Requests

You&#x27;re probably wondering how by using **Unirest** makes creating requests easier. Besides automatically supporting gzip, and
 parsing responses, lets start with a basic working example:

```js
unirest.<span class="apidocCodeKeywordSpan">post</span>(&#x27;http://mockbin.com/request&#x27;)
.headers({&#x27;Accept&#x27;: &#x27;application/json&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;})
.send({ &#x22;parameter&#x22;: 23, &#x22;foo&#x22;: &#x22;bar&#x22; })
.end(function (response) {
  console.log(response.body);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.put" id="apidoc.element.unirest.request.put">
        function <span class="apidocSignatureSpan">unirest.request.</span>put
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">put = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.method = method
  return request(params, params.callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Request = unirest.head(&#x27;http://mockbin.com/request&#x27;);
```

### put
Returns a [Request](#request) object with the `method` option set to `PUT`

```js
var Request = unirest.<span class="apidocCodeKeywordSpan">put</span>(&#x27;http://mockbin.com/request&#x27;);
```

### post
Returns a [Request](#request) object with the `method` option set to `POST`

```js
var Request = unirest.post(&#x27;http://mockbin.com/request&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unirest.request.Request" id="apidoc.module.unirest.request.Request">module unirest.request.Request</a></h1>


    <h2>
        <a href="#apidoc.element.unirest.request.Request.Request" id="apidoc.element.unirest.request.Request.Request">
        function <span class="apidocSignatureSpan">unirest.request.</span>Request
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Request(options) {
  // if given the method property in options, set property explicitMethod to true

  // extend the Request instance with any non-reserved properties
  // remove any reserved functions from the options object
  // set Request instance to be readable and writable
  // call init

  var self = this

  // start with HAR, then override with additional options
  if (options.har) {
    self._har = new Har(self)
    options = self._har.options(options)
  }

  stream.Stream.call(self)
  var reserved = Object.keys(Request.prototype)
  var nonReserved = filterForNonReserved(reserved, options)

  extend(self, nonReserved)
  options = filterOutReservedFunctions(reserved, options)

  self.readable = true
  self.writable = true
  if (options.method) {
    self.explicitMethod = true
  }
  self._qs = new Querystring(self)
  self._auth = new Auth(self)
  self._oauth = new OAuth(self)
  self._multipart = new Multipart(self)
  self._redirect = new Redirect(self)
  self._tunnel = new Tunnel(self)
  self.init(options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.super_" id="apidoc.element.unirest.request.Request.super_">
        function <span class="apidocSignatureSpan">unirest.request.Request.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unirest.request.Request.prototype" id="apidoc.module.unirest.request.Request.prototype">module unirest.request.Request.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.abort" id="apidoc.element.unirest.request.Request.prototype.abort">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abort = function () {
  var self = this
  self._aborted = true

  if (self.req) {
    self.req.abort()
  }
  else if (self.response) {
    self.response.destroy()
  }

  self.emit(&#x27;abort&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.auth" id="apidoc.element.unirest.request.Request.prototype.auth">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>auth
        <span class="apidocSignatureSpan">(user, pass, sendImmediately, bearer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auth = function (user, pass, sendImmediately, bearer) {
  var self = this

  self._auth.onRequest(user, pass, sendImmediately, bearer)

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

## Request Methods

Request Methods differ from Option Methods (See Below) in that these methods transform, or handle the data in a sugared way, where
 as Option Methods require a more _hands on_ approach.

#### Request.<span class="apidocCodeKeywordSpan">auth</span>(Object) or (user, pass, sendImmediately)

Accepts either an `Object` containing `user`, `pass`, and optionally `sendImmediately`.

- `user` (`String`) - Authentication Username
- `pass` (`String`) - Authentication Password
- `sendImmediately` (`String`) - _Optional_; Defaults to `true`; Flag to determine whether Request should send the basic authentication
 header along with the request. Upon being _false_, Request will retry with a _proper_ authentication header after receiving a `
401` response from the server (which must contain a `WWW-Authenticate` header indicating the required authentication method)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.aws" id="apidoc.element.unirest.request.Request.prototype.aws">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>aws
        <span class="apidocSignatureSpan">(opts, now)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aws = function (opts, now) {
  var self = this

  if (!now) {
    self._aws = opts
    return self
  }

  if (opts.sign_version == 4 || opts.sign_version == &#x27;4&#x27;) {
    // use aws4
    var options = {
      host: self.uri.host,
      path: self.uri.path,
      method: self.method,
      headers: {
        &#x27;content-type&#x27;: self.getHeader(&#x27;content-type&#x27;) || &#x27;&#x27;
      },
      body: self.body
    }
    var signRes = aws4.sign(options, {
      accessKeyId: opts.key,
      secretAccessKey: opts.secret
    })
    self.setHeader(&#x27;authorization&#x27;, signRes.headers.Authorization)
    self.setHeader(&#x27;x-amz-date&#x27;, signRes.headers[&#x27;X-Amz-Date&#x27;])
  }
  else {
    // default: use aws-sign2
    var date = new Date()
    self.setHeader(&#x27;date&#x27;, date.toUTCString())
    var auth =
      { key: opts.key
      , secret: opts.secret
      , verb: self.method.toUpperCase()
      , date: date
      , contentType: self.getHeader(&#x27;content-type&#x27;) || &#x27;&#x27;
      , md5: self.getHeader(&#x27;content-md5&#x27;) || &#x27;&#x27;
      , amazonHeaders: aws2.canonicalizeHeaders(self.headers)
      }
    var path = self.uri.path
    if (opts.bucket &#x26;&#x26; path) {
      auth.resource = &#x27;/&#x27; + opts.bucket + path
    } else if (opts.bucket &#x26;&#x26; !path) {
      auth.resource = &#x27;/&#x27; + opts.bucket
    } else if (!opts.bucket &#x26;&#x26; path) {
      auth.resource = path
    } else if (!opts.bucket &#x26;&#x26; !path) {
      auth.resource = &#x27;/&#x27;
    }
    auth.resource = aws2.canonicalizeResource(auth.resource)
    self.setHeader(&#x27;authorization&#x27;, aws2.authorization(auth))
  }

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `timeout` (`Number`) - Number of milliseconds to wait before aborting.
* `proxy` (`String`) - See `Request.proxy()` below.
* `oauth` (`Object`) - See `Request.oauth()` below.
* `hawk` (`Object`) - See `Request.hawk()` below
* `strictSSL` (`Boolean`) - Default `true`; See `Request.strictSSL()` below.
* `secureProtocol` (`String`) - See `Request.secureProtocol()` below.
* `jar` (`Boolean` | `Jar`) - See `Request.jar()` below.
* `aws` (`Object`) - See `Request.<span class="apidocCodeKeywordSpan">aws</span>()` below.
* `httpSignature` (`Object`) - See `Request.httpSignature()` Below.
* `localAddress` (`String`) - See `Request.localAddress()` Below.
* `pool` (`Object`) - See `Request.pool()` Below.
* `forever` (`Boolean`) - Default `undefined`; See `Request.forever()` Below

## Request Option Methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.debug" id="apidoc.element.unirest.request.Request.prototype.debug">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>debug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function debug() {
  if (Request.debug) {
    console.error(&#x27;REQUEST %s&#x27;, util.format.apply(util, arguments))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.destroy" id="apidoc.element.unirest.request.Request.prototype.destroy">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  var self = this
  if (!self._ended) {
    self.end()
  } else if (self.response) {
    self.response.destroy()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.enableUnixSocket" id="apidoc.element.unirest.request.Request.prototype.enableUnixSocket">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>enableUnixSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableUnixSocket = function () {
  // Get the socket &#x26; request paths from the URL
  var unixParts = this.uri.path.split(&#x27;:&#x27;)
    , host = unixParts[0]
    , path = unixParts[1]
  // Apply unix properties to request
  this.socketPath = host
  this.uri.pathname = path
  this.uri.path = path
  this.uri.host = host
  this.uri.hostname = host
  this.uri.isUnix = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.end" id="apidoc.element.unirest.request.Request.prototype.end">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk) {
  var self = this
  if (self._aborted) {return}

  if (chunk) {
    self.write(chunk)
  }
  if (!self._started) {
    self.start()
  }
  if (self.req) {
    self.req.end()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You&#x27;re probably wondering how by using **Unirest** makes creating requests easier. Besides automatically supporting gzip, and
 parsing responses, lets start with a basic working example:

```js
unirest.post(&#x27;http://mockbin.com/request&#x27;)
.headers({&#x27;Accept&#x27;: &#x27;application/json&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;})
.send({ &#x22;parameter&#x22;: 23, &#x22;foo&#x22;: &#x22;bar&#x22; })
.<span class="apidocCodeKeywordSpan">end</span>(function (response) {
  console.log(response.body);
});
```

## Uploading Files

Transferring file data has been simplified:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.form" id="apidoc.element.unirest.request.Request.prototype.form">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>form
        <span class="apidocSignatureSpan">(form)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">form = function (form) {
  var self = this
  if (form) {
    if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader(&#x27;content-type&#x27;))) {
      self.setHeader(&#x27;content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)
    }
    self.body = (typeof form === &#x27;string&#x27;)
      ? self._qs.rfc3986(form.toString(&#x27;utf8&#x27;))
      : self._qs.stringify(form).toString(&#x27;utf8&#x27;)
    return self
  }
  // create form-data object
  self._form = new FormData()
  self._form.on(&#x27;error&#x27;, function(err) {
    err.message = &#x27;form-data: &#x27; + err.message
    self.emit(&#x27;error&#x27;, err)
    self.abort()
  })
  return self._form
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Sets `method` value on `Request.options` to the given value.

```js
Request.method(&#x27;HEAD&#x27;);
```

#### Request.<span class="apidocCodeKeywordSpan">form</span>(Object)

Sets `form` object on `Request.options` to the given object.

When used `body` is set to the object passed as a `querystring` representation and the `Content-Type` header to `application/x-www
-form-urlencoded; charset=utf-8`

```js
Request.form({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.getHeader" id="apidoc.element.unirest.request.Request.prototype.getHeader">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>getHeader
        <span class="apidocSignatureSpan">(name, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHeader = function (name, headers) {
  var self = this
  var result, re, match
  if (!headers) {
    headers = self.headers
  }
  Object.keys(headers).forEach(function (key) {
    if (key.length !== name.length) {
      return
    }
    re = new RegExp(name, &#x27;i&#x27;)
    match = key.match(re)
    if (match) {
      result = headers[key]
    }
  })
  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.getNewAgent" id="apidoc.element.unirest.request.Request.prototype.getNewAgent">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>getNewAgent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNewAgent = function () {
  var self = this
  var Agent = self.agentClass
  var options = {}
  if (self.agentOptions) {
    for (var i in self.agentOptions) {
      options[i] = self.agentOptions[i]
    }
  }
  if (self.ca) {
    options.ca = self.ca
  }
  if (self.ciphers) {
    options.ciphers = self.ciphers
  }
  if (self.secureProtocol) {
    options.secureProtocol = self.secureProtocol
  }
  if (self.secureOptions) {
    options.secureOptions = self.secureOptions
  }
  if (typeof self.rejectUnauthorized !== &#x27;undefined&#x27;) {
    options.rejectUnauthorized = self.rejectUnauthorized
  }

  if (self.cert &#x26;&#x26; self.key) {
    options.key = self.key
    options.cert = self.cert
  }

  if (self.pfx) {
    options.pfx = self.pfx
  }

  if (self.passphrase) {
    options.passphrase = self.passphrase
  }

  var poolKey = &#x27;&#x27;

  // different types of agents are in different pools
  if (Agent !== self.httpModule.Agent) {
    poolKey += Agent.name
  }

  // ca option is only relevant if proxy or destination are https
  var proxy = self.proxy
  if (typeof proxy === &#x27;string&#x27;) {
    proxy = url.parse(proxy)
  }
  var isHttps = (proxy &#x26;&#x26; proxy.protocol === &#x27;https:&#x27;) || this.uri.protocol === &#x27;https:&#x27;

  if (isHttps) {
    if (options.ca) {
      if (poolKey) {
        poolKey += &#x27;:&#x27;
      }
      poolKey += options.ca
    }

    if (typeof options.rejectUnauthorized !== &#x27;undefined&#x27;) {
      if (poolKey) {
        poolKey += &#x27;:&#x27;
      }
      poolKey += options.rejectUnauthorized
    }

    if (options.cert) {
      if (poolKey) {
        poolKey += &#x27;:&#x27;
      }
      poolKey += options.cert.toString(&#x27;ascii&#x27;) + options.key.toString(&#x27;ascii&#x27;)
    }

    if (options.pfx) {
      if (poolKey) {
        poolKey += &#x27;:&#x27;
      }
      poolKey += options.pfx.toString(&#x27;ascii&#x27;)
    }

    if (options.ciphers) {
      if (poolKey) {
        poolKey += &#x27;:&#x27;
      }
      poolKey += options.ciphers
    }

    if (options.secureProtocol) {
      if (poolKey) {
        poolKey += &#x27;:&#x27;
      }
      poolKey += options.secureProtocol
    }

    if (options.secureOptions) {
      if (poolKey) {
        poolKey += &#x27;:&#x27;
      }
      poolKey += options.secureOptions
    }
  }

  if (self.pool === globalPool &#x26;&#x26; !poolKey &#x26;&#x26; Object.keys(options).length === 0 &#x26;&#x26; self.httpModule.globalAgent) {
    // not doing anything special.  Use the globalAgent
    return self.httpModule.globalAgent
  }

  // we&#x27;re using a stored agent.  Make sure it&#x27;s protocol-specific
  poolKey = self.uri.protocol + poolKey

  // generate a new agent for this setting if none yet exists
  if (!self.pool[poolKey]) {
    self.pool[poolKey] = new Agent(options)
    // properly set maxSockets on new agents
    if (self.pool.maxSockets) {
      self.pool[poolKey].maxSockets = self.pool.maxSockets
    }
  }

  return self.pool[poolKey]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.hawk" id="apidoc.element.unirest.request.Request.prototype.hawk">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>hawk
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hawk = function (opts) {
  var self = this
  self.setHeader(&#x27;Authorization&#x27;, hawk.client.header(self.uri, self.method, opts).field)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `followRedirect` (`Boolean`) - Default `true`; Follow HTTP `3xx` responses as redirects.
* `followAllRedirects` (`Boolean`) - Default `false`; Follow **Non**-GET HTTP `3xx` responses as redirects.
* `maxRedirects` (`Number`) - Default `10`; Maximum number of redirects before aborting.
* `encoding` (`String`) - Encoding to be used on `setEncoding` of response data.
* `timeout` (`Number`) - Number of milliseconds to wait before aborting.
* `proxy` (`String`) - See `Request.proxy()` below.
* `oauth` (`Object`) - See `Request.oauth()` below.
* `hawk` (`Object`) - See `Request.<span class="apidocCodeKeywordSpan">hawk</span>()` below
* `strictSSL` (`Boolean`) - Default `true`; See `Request.strictSSL()` below.
* `secureProtocol` (`String`) - See `Request.secureProtocol()` below.
* `jar` (`Boolean` | `Jar`) - See `Request.jar()` below.
* `aws` (`Object`) - See `Request.aws()` below.
* `httpSignature` (`Object`) - See `Request.httpSignature()` Below.
* `localAddress` (`String`) - See `Request.localAddress()` Below.
* `pool` (`Object`) - See `Request.pool()` Below.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.httpSignature" id="apidoc.element.unirest.request.Request.prototype.httpSignature">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>httpSignature
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">httpSignature = function (opts) {
  var self = this
  httpSignature.signRequest({
    getHeader: function(header) {
      return self.getHeader(header, self.headers)
    },
    setHeader: function(header, value) {
      self.setHeader(header, value)
    },
    method: self.method,
    path: self.path
  }, opts)
  debug(&#x27;httpSignature authorization&#x27;, self.getHeader(&#x27;authorization&#x27;))

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `proxy` (`String`) - See `Request.proxy()` below.
* `oauth` (`Object`) - See `Request.oauth()` below.
* `hawk` (`Object`) - See `Request.hawk()` below
* `strictSSL` (`Boolean`) - Default `true`; See `Request.strictSSL()` below.
* `secureProtocol` (`String`) - See `Request.secureProtocol()` below.
* `jar` (`Boolean` | `Jar`) - See `Request.jar()` below.
* `aws` (`Object`) - See `Request.aws()` below.
* `httpSignature` (`Object`) - See `Request.<span class="apidocCodeKeywordSpan">httpSignature</span>()` Below.
* `localAddress` (`String`) - See `Request.localAddress()` Below.
* `pool` (`Object`) - See `Request.pool()` Below.
* `forever` (`Boolean`) - Default `undefined`; See `Request.forever()` Below

## Request Option Methods

#### Request.url(String)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.init" id="apidoc.element.unirest.request.Request.prototype.init">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>init
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (options) {
  // init() contains all the code to setup the request object.
  // the actual outgoing request is not started until start() is called
  // this function is called from both the constructor and on redirect.
  var self = this
  if (!options) {
    options = {}
  }
  self.headers = self.headers ? copy(self.headers) : {}

  // Delete headers with value undefined since they break
  // ClientRequest.OutgoingMessage.setHeader in node 0.12
  for (var headerName in self.headers) {
    if (typeof self.headers[headerName] === &#x27;undefined&#x27;) {
      delete self.headers[headerName]
    }
  }

  caseless.httpify(self, self.headers)

  if (!self.method) {
    self.method = options.method || &#x27;GET&#x27;
  }
  if (!self.localAddress) {
    self.localAddress = options.localAddress
  }

  self._qs.init(options)

  debug(options)
  if (!self.pool &#x26;&#x26; self.pool !== false) {
    self.pool = globalPool
  }
  self.dests = self.dests || []
  self.__isRequestRequest = true

  // Protect against double callback
  if (!self._callback &#x26;&#x26; self.callback) {
    self._callback = self.callback
    self.callback = function () {
      if (self._callbackCalled) {
        return // Print a warning maybe?
      }
      self._callbackCalled = true
      self._callback.apply(self, arguments)
    }
    self.on(&#x27;error&#x27;, self.callback.bind())
    self.on(&#x27;complete&#x27;, self.callback.bind(self, null))
  }

  // People use this property instead all the time, so support it
  if (!self.uri &#x26;&#x26; self.url) {
    self.uri = self.url
    delete self.url
  }

  // If there&#x27;s a baseUrl, then use it as the base URL (i.e. uri must be
  // specified as a relative path and is appended to baseUrl).
  if (self.baseUrl) {
    if (typeof self.baseUrl !== &#x27;string&#x27;) {
      return self.emit(&#x27;error&#x27;, new Error(&#x27;options.baseUrl must be a string&#x27;))
    }

    if (typeof self.uri !== &#x27;string&#x27;) {
      return self.emit(&#x27;error&#x27;, new Error(&#x27;options.uri must be a string when using options.baseUrl&#x27;))
    }

    if (self.uri.indexOf(&#x27;//&#x27;) === 0 || self.uri.indexOf(&#x27;://&#x27;) !== -1) {
      return self.emit(&#x27;error&#x27;, new Error(&#x27;options.uri must be a path when using options.baseUrl&#x27;))
    }

    // Handle all cases to make sure that there&#x27;s only one slash between
    // baseUrl and uri.
    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf(&#x27;/&#x27;) === self.baseUrl.length - 1
    var uriStartsWithSlash = self.uri.indexOf(&#x27;/&#x27;) === 0

    if (baseUrlEndsWithSlash &#x26;&#x26; uriStartsWithSlash) {
      self.uri = self.baseUrl + self.uri.slice(1)
    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
      self.uri = self.baseUrl + self.uri
    } else if (self.uri === &#x27;&#x27;) {
      self.uri = self.baseUrl
    } else {
      self.uri = self.baseUrl + &#x27;/&#x27; + self.uri
    }
    delete self.baseUrl
  }

  // A URI is needed by this point, emit error if we haven&#x27;t been able to get one
  if (!self.uri) {
    return self.emit(&#x27;error&#x27;, new Error(&#x27;options.uri is a required argument&#x27;))
  }

  // If a string URI/URL was given, parse it into a URL object
  if (typeof self.uri === &#x27;string&#x27;) {
    self.uri = url.parse(self.uri)
  }

  // Some URL objects are not from a URL parsed string and need href added
  if (!self.uri.href) {
    self.uri.href = url.format(self.uri)
  }

  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme
  if (self.uri.protocol === &#x27;unix:&#x27;) {
    return self.emit(&#x27;error&#x27;, new Error(&#x27;`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:
PATH`&#x27;))
  }

  // Support Unix Sockets
  if (self.uri.host === &#x27;unix&#x27;) {
    self.enableUnixSocket()
  }

  if (self.strictSSL === false) {
    self.rejectUnauthorized = false
  }

  if (!self.uri.pathname) {self.uri.pathname = &#x27;/&#x27;}

  if (!(self.uri.host || (self.uri.hostname &#x26;&#x26; self.uri.port)) &#x26;&#x26; !self.uri.isUnix) {
    // Invalid URI: it may generate lot of bad errors, like &#x27;TypeError: Cannot call method `indexOf` of undefined&#x27; in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri)
    var message = &#x27;Invalid URI &#x22;&#x27; + faultyUri + &#x27;&#x22;&#x27;
    if (Object.keys(options). ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.jar" id="apidoc.element.unirest.request.Request.prototype.jar">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>jar
        <span class="apidocSignatureSpan">(jar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jar = function (jar) {
  var self = this
  var cookies

  if (self._redirect.redirectsFollowed === 0) {
    self.originalCookieHeader = self.getHeader(&#x27;cookie&#x27;)
  }

  if (!jar) {
    // disable cookies
    cookies = false
    self._disableCookies = true
  } else {
    var targetCookieJar = (jar &#x26;&#x26; jar.getCookieString) ? jar : globalCookieJar
    var urihref = self.uri.href
    //fetch cookie in the Specified host
    if (targetCookieJar) {
      cookies = targetCookieJar.getCookieString(urihref)
    }
  }

  //if need cookie and cookie is not empty
  if (cookies &#x26;&#x26; cookies.length) {
    if (self.originalCookieHeader) {
      // Don&#x27;t overwrite existing Cookie header
      self.setHeader(&#x27;cookie&#x27;, self.originalCookieHeader + &#x27;; &#x27; + cookies)
    } else {
      self.setHeader(&#x27;cookie&#x27;, cookies)
    }
  }
  self._jar = jar
  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### delete
Returns a [Request](#request) object with the `method` option set to `DELETE`

```js
var Request = unirest.delete(&#x27;http://mockbin.com/request&#x27;);
```

## unirest.<span class="apidocCodeKeywordSpan">jar</span>()

Creates a container to store multiple cookies, i.e. a cookie jar.

```js
var CookieJar = unirest.jar();
CookieJar.add(&#x27;key=value&#x27;, &#x27;/&#x27;); // Cookie string, pathname / url
unirest.get(&#x27;http://mockbin.com/request&#x27;).jar(CookieJar);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.json" id="apidoc.element.unirest.request.Request.prototype.json">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>json
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (val) {
  var self = this

  if (!self.hasHeader(&#x27;accept&#x27;)) {
    self.setHeader(&#x27;accept&#x27;, &#x27;application/json&#x27;)
  }

  if (typeof self.jsonReplacer === &#x27;function&#x27;) {
    self._jsonReplacer = self.jsonReplacer
  }

  self._json = true
  if (typeof val === &#x27;boolean&#x27;) {
    if (self.body !== undefined) {
      if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader(&#x27;content-type&#x27;))) {
        self.body = safeStringify(self.body, self._jsonReplacer)
      } else {
        self.body = self._qs.rfc3986(self.body)
      }
      if (!self.hasHeader(&#x27;content-type&#x27;)) {
        self.setHeader(&#x27;content-type&#x27;, &#x27;application/json&#x27;)
      }
    }
  } else {
    self.body = safeStringify(val, self._jsonReplacer)
    if (!self.hasHeader(&#x27;content-type&#x27;)) {
      self.setHeader(&#x27;content-type&#x27;, &#x27;application/json&#x27;)
    }
  }

  if (typeof self.jsonReviver === &#x27;function&#x27;) {
    self._jsonReviver = self.jsonReviver
  }

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (is(options).a(Object)) {
  if (options[&#x27;content-type&#x27;]) {
    var type = Unirest.type(options[&#x27;content-type&#x27;], true)
    if (type) options.body = Unirest.Response.parse(options.body)
  } else {
    if (is(options.body).a(Object)) {
      options.body = Unirest.serializers.<span class="apidocCodeKeywordSpan">json</span>(options.body)
    }
  }

  $this.options.multipart.push(options)
} else {
  $this.options.multipart.push({
    body: options
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.multipart" id="apidoc.element.unirest.request.Request.prototype.multipart">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>multipart
        <span class="apidocSignatureSpan">(multipart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multipart = function (multipart) {
  var self = this

  self._multipart.onRequest(multipart)

  if (!self._multipart.chunked) {
    self.body = self._multipart.body
  }

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Request.header(&#x27;Accept&#x27;, &#x27;application/json&#x27;);
```

#### Request.part(Object)

**Experimental**

Similiar to `Request.<span class="apidocCodeKeywordSpan">multipart</span>()` except it only allows one object to be passed at a
time and does the pre-processing on necessary `body` values for you.

Each object is then appended to the `Request.options.multipart` array.

```js
Request.part({
&#x27;content-type&#x27;: &#x27;application/json&#x27;,
body: { foo: &#x27;bar&#x27; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.oauth" id="apidoc.element.unirest.request.Request.prototype.oauth">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>oauth
        <span class="apidocSignatureSpan">(_oauth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">oauth = function (_oauth) {
  var self = this

  self._oauth.onRequest(_oauth)

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `multipart` (`Object`) - _Experimental_; See documentation below.
* `followRedirect` (`Boolean`) - Default `true`; Follow HTTP `3xx` responses as redirects.
* `followAllRedirects` (`Boolean`) - Default `false`; Follow **Non**-GET HTTP `3xx` responses as redirects.
* `maxRedirects` (`Number`) - Default `10`; Maximum number of redirects before aborting.
* `encoding` (`String`) - Encoding to be used on `setEncoding` of response data.
* `timeout` (`Number`) - Number of milliseconds to wait before aborting.
* `proxy` (`String`) - See `Request.proxy()` below.
* `oauth` (`Object`) - See `Request.<span class="apidocCodeKeywordSpan">oauth</span>()` below.
* `hawk` (`Object`) - See `Request.hawk()` below
* `strictSSL` (`Boolean`) - Default `true`; See `Request.strictSSL()` below.
* `secureProtocol` (`String`) - See `Request.secureProtocol()` below.
* `jar` (`Boolean` | `Jar`) - See `Request.jar()` below.
* `aws` (`Object`) - See `Request.aws()` below.
* `httpSignature` (`Object`) - See `Request.httpSignature()` Below.
* `localAddress` (`String`) - See `Request.localAddress()` Below.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.onRequestError" id="apidoc.element.unirest.request.Request.prototype.onRequestError">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>onRequestError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onRequestError = function (error) {
  var self = this
  if (self._aborted) {
    return
  }
  if (self.req &#x26;&#x26; self.req._reusedSocket &#x26;&#x26; error.code === &#x27;ECONNRESET&#x27;
      &#x26;&#x26; self.agent.addRequestNoreuse) {
    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
    self.start()
    self.req.end()
    return
  }
  if (self.timeout &#x26;&#x26; self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }
  self.emit(&#x27;error&#x27;, error)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.onRequestResponse" id="apidoc.element.unirest.request.Request.prototype.onRequestResponse">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>onRequestResponse
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onRequestResponse = function (response) {
  var self = this
  debug(&#x27;onRequestResponse&#x27;, self.uri.href, response.statusCode, response.headers)
  response.on(&#x27;end&#x27;, function() {
    if (self.timing) {
      self.elapsedTime += (new Date().getTime() - self.startTime)
      debug(&#x27;elapsed time&#x27;, self.elapsedTime)
      response.elapsedTime = self.elapsedTime
    }
    debug(&#x27;response end&#x27;, self.uri.href, response.statusCode, response.headers)
  })

  if (self._aborted) {
    debug(&#x27;aborted&#x27;, self.uri.href)
    response.resume()
    return
  }

  self.response = response
  response.request = self
  response.toJSON = responseToJSON

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &#x26;&#x26;
      self.strictSSL &#x26;&#x26; (!response.hasOwnProperty(&#x27;socket&#x27;) ||
      !response.socket.authorized)) {
    debug(&#x27;strict ssl error&#x27;, self.uri.href)
    var sslErr = response.hasOwnProperty(&#x27;socket&#x27;) ? response.socket.authorizationError : self.uri.href + &#x27; does not support SSL
&#x27;
    self.emit(&#x27;error&#x27;, new Error(&#x27;SSL Error: &#x27; + sslErr))
    return
  }

  // Save the original host before any redirect (if it changes, we need to
  // remove any authorization headers).  Also remember the case of the header
  // name because lots of broken servers expect Host instead of host and we
  // want the caller to be able to specify this.
  self.originalHost = self.getHeader(&#x27;host&#x27;)
  if (!self.originalHostHeaderName) {
    self.originalHostHeaderName = self.hasHeader(&#x27;host&#x27;)
  }
  if (self.setHost) {
    self.removeHeader(&#x27;host&#x27;)
  }
  if (self.timeout &#x26;&#x26; self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }

  var targetCookieJar = (self._jar &#x26;&#x26; self._jar.setCookie) ? self._jar : globalCookieJar
  var addCookie = function (cookie) {
    //set the cookie if it&#x27;s domain in the href&#x27;s domain.
    try {
      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})
    } catch (e) {
      self.emit(&#x27;error&#x27;, e)
    }
  }

  response.caseless = caseless(response.headers)

  if (response.caseless.has(&#x27;set-cookie&#x27;) &#x26;&#x26; (!self._disableCookies)) {
    var headerName = response.caseless.has(&#x27;set-cookie&#x27;)
    if (Array.isArray(response.headers[headerName])) {
      response.headers[headerName].forEach(addCookie)
    } else {
      addCookie(response.headers[headerName])
    }
  }

  if (self._redirect.onResponse(response)) {
    return // Ignore the rest of the response
  } else {
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on(&#x27;close&#x27;, function () {
      if (!self._ended) {
        self.response.emit(&#x27;end&#x27;)
      }
    })

    response.on(&#x27;end&#x27;, function () {
      self._ended = true
    })

    var noBody = function (code) {
      return (
        self.method === &#x27;HEAD&#x27;
        // Informational
        || (code &#x3e;= 100 &#x26;&#x26; code &#x3c; 200)
        // No Content
        || code === 204
        // Not Modified
        || code === 304
      )
    }

    var responseContent
    if (self.gzip &#x26;&#x26; !noBody(response.statusCode)) {
      var contentEncoding = response.headers[&#x27;content-encoding&#x27;] || &#x27;identity&#x27;
      contentEncoding = contentEncoding.trim().toLowerCase()

      if (contentEncoding === &#x27;gzip&#x27;) {
        responseContent = zlib.createGunzip()
        response.pipe(responseContent)
      } else if (contentEncoding === &#x27;deflate&#x27;) {
        responseContent = zlib.createInflate()
        response.pipe(responseContent)
      } else {
        // Since previous versions didn&#x27;t check for Content-Encoding header,
        // ignore any invalid values to preserve backwards-compatibility
        if (contentEncoding !== &#x27;identity&#x27;) {
          debug(&#x27;ignoring unrecognized Content-Encoding &#x27; + contentEncoding)
        }
        responseContent = response
      }
    } else {
      responseContent = response
    }

    if (self.encoding) {
      if (self.dests.length !== 0) {
        console.error(&#x27;Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding opti ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.pause" id="apidoc.element.unirest.request.Request.prototype.pause">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  var self = this
  if (!self.responseContent) {
    self._paused = true
  } else {
    self.responseContent.pause.apply(self.responseContent, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.pipe" id="apidoc.element.unirest.request.Request.prototype.pipe">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>pipe
        <span class="apidocSignatureSpan">(dest, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (dest, opts) {
  var self = this

  if (self.response) {
    if (self._destdata) {
      self.emit(&#x27;error&#x27;, new Error(&#x27;You cannot pipe after data has been emitted from the response.&#x27;))
    } else if (self._ended) {
      self.emit(&#x27;error&#x27;, new Error(&#x27;You cannot pipe after the response has been ended.&#x27;))
    } else {
      stream.Stream.prototype.pipe.call(self, dest, opts)
      self.pipeDest(dest)
      return dest
    }
  } else {
    self.dests.push(dest)
    stream.Stream.prototype.pipe.call(self, dest, opts)
    return dest
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return
  }

  stream.emit(&#x27;error&#x27;, error)
})

// Start the processing
response.<span class="apidocCodeKeywordSpan">pipe</span>(unzip)

// Ensure encoding is captured
response.setEncoding = function (type) {
  decoder = new StringDecoder(type)
}

// Capture decompression and decode with captured encoding
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.pipeDest" id="apidoc.element.unirest.request.Request.prototype.pipeDest">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>pipeDest
        <span class="apidocSignatureSpan">(dest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipeDest = function (dest) {
  var self = this
  var response = self.response
  // Called after the response is received
  if (dest.headers &#x26;&#x26; !dest.headersSent) {
    if (response.caseless.has(&#x27;content-type&#x27;)) {
      var ctname = response.caseless.has(&#x27;content-type&#x27;)
      if (dest.setHeader) {
        dest.setHeader(ctname, response.headers[ctname])
      }
      else {
        dest.headers[ctname] = response.headers[ctname]
      }
    }

    if (response.caseless.has(&#x27;content-length&#x27;)) {
      var clname = response.caseless.has(&#x27;content-length&#x27;)
      if (dest.setHeader) {
        dest.setHeader(clname, response.headers[clname])
      } else {
        dest.headers[clname] = response.headers[clname]
      }
    }
  }
  if (dest.setHeader &#x26;&#x26; !dest.headersSent) {
    for (var i in response.headers) {
      // If the response content is being decoded, the Content-Encoding header
      // of the response doesn&#x27;t represent the piped content, so don&#x27;t pass it.
      if (!self.gzip || i !== &#x27;content-encoding&#x27;) {
        dest.setHeader(i, response.headers[i])
      }
    }
    dest.statusCode = response.statusCode
  }
  if (self.pipefilter) {
    self.pipefilter(response, dest)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.qs" id="apidoc.element.unirest.request.Request.prototype.qs">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>qs
        <span class="apidocSignatureSpan">(q, clobber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">qs = function (q, clobber) {
  var self = this
  var base
  if (!clobber &#x26;&#x26; self.uri.query) {
    base = self._qs.parse(self.uri.query)
  } else {
    base = {}
  }

  for (var i in q) {
    base[i] = q[i]
  }

  var qs = self._qs.stringify(base)

  if (qs === &#x27;&#x27;) {
    return self
  }

  self.uri = url.parse(self.uri.href.split(&#x27;?&#x27;)[0] + &#x27;?&#x27; + qs)
  self.url = self.uri
  self.path = self.uri.path

  if (self.uri.host === &#x27;unix&#x27;) {
    self.enableUnixSocket()
  }

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.readResponseBody" id="apidoc.element.unirest.request.Request.prototype.readResponseBody">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>readResponseBody
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readResponseBody = function (response) {
  var self = this
  debug(&#x27;reading response\&#x27;s body&#x27;)
  var buffer = bl()
    , strings = []

  self.on(&#x27;data&#x27;, function (chunk) {
    if (Buffer.isBuffer(chunk)) {
      buffer.append(chunk)
    } else {
      strings.push(chunk)
    }
  })
  self.on(&#x27;end&#x27;, function () {
    debug(&#x27;end event&#x27;, self.uri.href)
    if (self._aborted) {
      debug(&#x27;aborted&#x27;, self.uri.href)
      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.
      // This can lead to leaky behavior if the user retains a reference to the request object.
      buffer.destroy()
      return
    }

    if (buffer.length) {
      debug(&#x27;has body&#x27;, self.uri.href, buffer.length)
      if (self.encoding === null) {
        // response.body = buffer
        // can&#x27;t move to this until https://github.com/rvagg/bl/issues/13
        response.body = buffer.slice()
      } else {
        response.body = buffer.toString(self.encoding)
      }
      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.
      // This can lead to leaky behavior if the user retains a reference to the request object.
      buffer.destroy()
    } else if (strings.length) {
      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
      // Strip this value out when the encoding is set to &#x27;utf8&#x27;, as upstream consumers won&#x27;t expect it and it breaks JSON.parse
().
      if (self.encoding === &#x27;utf8&#x27; &#x26;&#x26; strings[0].length &#x3e; 0 &#x26;&#x26; strings[0][0] === &#x27;\uFEFF&#x27;) {
        strings[0] = strings[0].substring(1)
      }
      response.body = strings.join(&#x27;&#x27;)
    }

    if (self._json) {
      try {
        response.body = JSON.parse(response.body, self._jsonReviver)
      } catch (e) {
        debug(&#x27;invalid JSON received&#x27;, self.uri.href)
      }
    }
    debug(&#x27;emitting complete&#x27;, self.uri.href)
    if (typeof response.body === &#x27;undefined&#x27; &#x26;&#x26; !self._json) {
      response.body = self.encoding === null ? new Buffer(0) : &#x27;&#x27;
    }
    self.emit(&#x27;complete&#x27;, response, response.body)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.resume" id="apidoc.element.unirest.request.Request.prototype.resume">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  var self = this
  if (!self.responseContent) {
    self._paused = false
  } else {
    self.responseContent.resume.apply(self.responseContent, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (!response.body) {
  response.body = &#x27;&#x27;
}

// Node 10+
response.<span class="apidocCodeKeywordSpan">resume</span>()

// GZIP, Feel me?
handleGZIPResponse(response)

// Fallback
response.on(&#x27;data&#x27;, function (chunk) {
  if (typeof chunk === &#x27;string&#x27;) response.body += chunk
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.start" id="apidoc.element.unirest.request.Request.prototype.start">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {
  // start() is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(), end() or on nextTick()
  var self = this

  if (self._aborted) {
    return
  }

  self._started = true
  self.method = self.method || &#x27;GET&#x27;
  self.href = self.uri.href

  if (self.src &#x26;&#x26; self.src.stat &#x26;&#x26; self.src.stat.size &#x26;&#x26; !self.hasHeader(&#x27;content-length&#x27;)) {
    self.setHeader(&#x27;content-length&#x27;, self.src.stat.size)
  }
  if (self._aws) {
    self.aws(self._aws, true)
  }

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don&#x27;t remove it, we&#x27;re gonna have a bad time.
  var reqOptions = copy(self)
  delete reqOptions.auth

  debug(&#x27;make request&#x27;, self.uri.href)

  try {
    self.req = self.httpModule.request(reqOptions)
  } catch (err) {
    self.emit(&#x27;error&#x27;, err)
    return
  }

  if (self.timing) {
    self.startTime = new Date().getTime()
  }

  if (self.timeout &#x26;&#x26; !self.timeoutTimer) {
    var timeout = self.timeout &#x3c; 0 ? 0 : self.timeout
    // Set a timeout in memory - this block will throw if the server takes more
    // than `timeout` to write the HTTP status and headers (corresponding to
    // the on(&#x27;response&#x27;) event on the client). NB: this measures wall-clock
    // time, not the time between bytes sent by the server.
    self.timeoutTimer = setTimeout(function () {
      var connectTimeout = self.req.socket &#x26;&#x26; self.req.socket.readable === false
      self.abort()
      var e = new Error(&#x27;ETIMEDOUT&#x27;)
      e.code = &#x27;ETIMEDOUT&#x27;
      e.connect = connectTimeout
      self.emit(&#x27;error&#x27;, e)
    }, timeout)

    if (self.req.setTimeout) { // only works on node 0.6+
      // Set an additional timeout on the socket, via the `setsockopt` syscall.
      // This timeout sets the amount of time to wait *between* bytes sent
      // from the server, and may or may not correspond to the wall-clock time
      // elapsed from the start of the request.
      //
      // In particular, it&#x27;s useful for erroring if the server fails to send
      // data halfway through streaming a response.
      self.req.setTimeout(timeout, function () {
        if (self.req) {
          self.req.abort()
          var e = new Error(&#x27;ESOCKETTIMEDOUT&#x27;)
          e.code = &#x27;ESOCKETTIMEDOUT&#x27;
          e.connect = false
          self.emit(&#x27;error&#x27;, e)
        }
      })
    }
  }

  self.req.on(&#x27;response&#x27;, self.onRequestResponse.bind(self))
  self.req.on(&#x27;error&#x27;, self.onRequestError.bind(self))
  self.req.on(&#x27;drain&#x27;, function() {
    self.emit(&#x27;drain&#x27;)
  })
  self.req.on(&#x27;socket&#x27;, function(socket) {
    self.emit(&#x27;socket&#x27;, socket)
  })

  self.emit(&#x27;request&#x27;, self.req)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.toJSON" id="apidoc.element.unirest.request.Request.prototype.toJSON">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function requestToJSON() {
  var self = this
  return {
    uri: self.uri,
    method: self.method,
    headers: self.headers
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.request.Request.prototype.write" id="apidoc.element.unirest.request.Request.prototype.write">
        function <span class="apidocSignatureSpan">unirest.request.Request.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var self = this
  if (self._aborted) {return}

  if (!self._started) {
    self.start()
  }
  if (self.req) {
    return self.req.write.apply(self.req, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
response.setEncoding = function (type) {
  decoder = new StringDecoder(type)
}

// Capture decompression and decode with captured encoding
unzip.on(&#x27;data&#x27;, function (buffer) {
  if (!decoder) return stream.emit(&#x27;data&#x27;, buffer)
  var string = decoder.<span class="apidocCodeKeywordSpan">write</span>(buffer)
  if (string.length) stream.emit(&#x27;data&#x27;, string)
})

// Emit yoself
unzip.on(&#x27;end&#x27;, function () {
  stream.emit(&#x27;end&#x27;)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unirest.serializers" id="apidoc.module.unirest.serializers">module unirest.serializers</a></h1>


    <h2>
        <a href="#apidoc.element.unirest.serializers.form" id="apidoc.element.unirest.serializers.form">
        function <span class="apidocSignatureSpan">unirest.serializers.</span>form
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">form = function (obj) {
  return QueryString.stringify(obj)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Sets `method` value on `Request.options` to the given value.

```js
Request.method(&#x27;HEAD&#x27;);
```

#### Request.<span class="apidocCodeKeywordSpan">form</span>(Object)

Sets `form` object on `Request.options` to the given object.

When used `body` is set to the object passed as a `querystring` representation and the `Content-Type` header to `application/x-www
-form-urlencoded; charset=utf-8`

```js
Request.form({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unirest.serializers.json" id="apidoc.element.unirest.serializers.json">
        function <span class="apidocSignatureSpan">unirest.serializers.</span>json
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (obj) {
  return JSON.stringify(obj)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (is(options).a(Object)) {
  if (options[&#x27;content-type&#x27;]) {
    var type = Unirest.type(options[&#x27;content-type&#x27;], true)
    if (type) options.body = Unirest.Response.parse(options.body)
  } else {
    if (is(options.body).a(Object)) {
      options.body = Unirest.serializers.<span class="apidocCodeKeywordSpan">json</span>(options.body)
    }
  }

  $this.options.multipart.push(options)
} else {
  $this.options.multipart.push({
    body: options
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
